{"version":3,"file":"VueFinalModal.esm.js","sources":["../lib/utils/focusTrap.js","../lib/utils/bodyScrollLock.js","../lib/VueFinalModal.vue","../lib/PluginCore.js","../lib/utils/errors.js","../lib/Plugin.js"],"sourcesContent":["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n","// stolen from body-scroll-lock\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    }\n  }\n  window.addEventListener('testPassive', null, passiveTestOptions)\n  window.removeEventListener('testPassive', null, passiveTestOptions)\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\n\nlet locks = []\nlet documentListenerAdded = false\nlet clientY = 0\nlet initialClientY = -1\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst hasScrollbar = el => {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\n\n  const style = window.getComputedStyle(el)\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\n}\n\nconst shouldScroll = (el, delta) => {\n  if (el.scrollTop === 0 && delta < 0) return false\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\n  return true\n}\n\nconst composedPath = el => {\n  const path = []\n  while (el) {\n    path.push(el)\n    if (el.classList.contains('vfm')) return path\n    el = el.parentElement\n  }\n  return path\n}\n\nconst hasAnyScrollableEl = (el, delta) => {\n  let hasAnyScrollableEl = false\n  const path = composedPath(el)\n  path.forEach(el => {\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\n      hasAnyScrollableEl = true\n    }\n  })\n  return hasAnyScrollableEl\n}\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\n\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = targetElement =>\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\n\nconst handleScroll = (event, targetElement) => {\n  clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {}\n  }\n\n  locks = [...locks, lock]\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = true\n    }\n  } else {\n    setOverflowHidden(options)\n  }\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = false\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      ref=\"vfmOverlayTransition\"\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-show=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      ref=\"vfmTransition\"\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @click.self=\"onClickContainer\"\n      >\n        <div class=\"vfm__content\" :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\" :style=\"contentStyle\">\n          <slot v-bind:params=\"params\" />\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport FocusTrap from './utils/focusTrap.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nfunction validateAttachTarget(val) {\n  const type = typeof val\n\n  if (type === 'boolean' || type === 'string') return true\n\n  return val.nodeType === Node.ELEMENT_NODE\n}\n\nconst STYLE_PROP = {\n  type: [String, Object, Array],\n  default: ''\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    value: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: STYLE_PROP,\n    overlayClass: STYLE_PROP,\n    contentClass: STYLE_PROP,\n    styles: STYLE_PROP,\n    overlayStyle: STYLE_PROP,\n    contentStyle: STYLE_PROP,\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: { type: null, default: false, validator: validateAttachTarget },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false }\n  },\n  data: () => ({\n    modalStackIndex: null,\n    visible: false,\n    visibility: {\n      modal: false,\n      overlay: false\n    },\n    overlayTransitionState: null,\n    modalTransitionState: null,\n    stopEvent: false,\n    params: {}\n  }),\n  computed: {\n    api() {\n      return this[this.$_options.key]\n    },\n    isComponentReadyToBeDestroyed() {\n      return (\n        (this.hideOverlay || this.overlayTransitionState === TransitionState.Leave) &&\n        this.modalTransitionState === TransitionState.Leave\n      )\n    },\n    calculateZIndex() {\n      if (this.zIndex === false) {\n        if (this.zIndexAuto) {\n          return +this.zIndexBase + 2 * (this.modalStackIndex || 0)\n        } else {\n          return false\n        }\n      } else {\n        return this.zIndex\n      }\n    },\n    bindStyle() {\n      return {\n        ...(this.calculateZIndex !== false && { zIndex: this.calculateZIndex })\n      }\n    },\n    computedTransition() {\n      if (typeof this.transition === 'string') return { name: this.transition }\n      return { ...this.transition }\n    },\n    computedOverlayTransition() {\n      if (typeof this.overlayTransition === 'string') return { name: this.overlayTransition }\n      return { ...this.overlayTransition }\n    }\n  },\n  watch: {\n    value(value) {\n      if (this.stopEvent) {\n        this.stopEvent = false\n        return\n      }\n      this.mounted()\n      if (!value) {\n        if (this.emitEvent('before-close', true)) {\n          return\n        }\n        this.close()\n      }\n    },\n    lockScroll: 'handleLockScroll',\n    hideOverlay(value) {\n      if (this.value && !value) {\n        this.visibility.overlay = true\n      }\n    },\n    attach: 'mounted',\n    isComponentReadyToBeDestroyed(isReady) {\n      if (isReady) {\n        this.visible = false\n      }\n    }\n  },\n  created() {\n    this.api.modals.push(this)\n  },\n  mounted() {\n    this.$focusTrap = new FocusTrap()\n    this.mounted()\n  },\n  beforeDestroy() {\n    this.close()\n    this.lockScroll && this.$refs.vfmContainer && enableBodyScroll(this.$refs.vfmContainer)\n    this?.$el?.remove()\n\n    let index = this.api.modals.findIndex(vm => vm === this)\n    this.api.modals.splice(index, 1)\n  },\n  methods: {\n    mounted() {\n      if (this.value) {\n        if (this.emitEvent('before-open', false)) {\n          return\n        }\n        let target = this.getAttachElement()\n        if (target || this.attach === false) {\n          this.attach !== false && target.appendChild(this.$el)\n\n          let index = this.api.openedModals.findIndex(vm => vm === this)\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            this.api.openedModals.splice(index, 1)\n          }\n          this.api.openedModals.push(this)\n\n          this.modalStackIndex = this.api.openedModals.length - 1\n\n          this.handleLockScroll()\n          this.api.openedModals\n            .filter(vm => vm !== this)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex = index\n                vm.visibility.overlay = false\n              }\n            })\n\n          this.visible = true\n          this.$nextTick(() => {\n            this.startTransitionEnter()\n          })\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(this.attach))\n        }\n      }\n    },\n    close() {\n      let index = this.api.openedModals.findIndex(vm => vm === this)\n      if (index !== -1) {\n        // remove this in modalStack\n        this.api.openedModals.splice(index, 1)\n      }\n      if (this.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = this.api.openedModals[this.api.openedModals.length - 1]\n        if ($_vm.focusRetain || $_vm.focusTrap) {\n          $_vm.$refs.vfmContainer.focus()\n        }\n        !$_vm.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      this.startTransitionLeave()\n    },\n    startTransitionEnter() {\n      this.visibility.overlay = true\n      this.visibility.modal = true\n    },\n    startTransitionLeave() {\n      this.visibility.overlay = false\n      this.visibility.modal = false\n    },\n    handleLockScroll() {\n      if (this.value) {\n        this.$nextTick(() => {\n          if (this.lockScroll) {\n            disableBodyScroll(this.$refs.vfmContainer, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(this.$refs.vfmContainer)\n          }\n        })\n      }\n    },\n    getAttachElement() {\n      let target\n      if (this.attach === false) {\n        target = false\n      } else if (typeof this.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(this.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = this.attach\n      }\n      return target\n    },\n    beforeOverlayEnter() {\n      this.overlayTransitionState = TransitionState.Entering\n    },\n    afterOverlayEnter() {\n      this.overlayTransitionState = TransitionState.Enter\n    },\n    beforeOverlayLeave() {\n      this.overlayTransitionState = TransitionState.Leaving\n    },\n    afterOverlayLeave() {\n      this.overlayTransitionState = TransitionState.Leave\n    },\n    beforeModalEnter() {\n      this.modalTransitionState = TransitionState.Entering\n    },\n    afterModalEnter() {\n      this.modalTransitionState = TransitionState.Enter\n      if (this.focusRetain || this.focusTrap) {\n        this.$refs.vfmContainer.focus()\n      }\n      if (this.focusTrap) {\n        this.$focusTrap.enable(this.$refs.vfmContainer)\n      }\n      this.$emit('opened', this.createModalEvent({ type: 'opened' }))\n    },\n    beforeModalLeave() {\n      this.modalTransitionState = TransitionState.Leaving\n\n      if (this.$focusTrap.enabled()) {\n        this.$focusTrap.disable()\n      }\n    },\n    afterModalLeave() {\n      this.modalTransitionState = TransitionState.Leave\n      this.modalStackIndex = null\n      this.lockScroll && enableBodyScroll(this.$refs.vfmContainer)\n\n      let stopEvent = false\n      const event = this.createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      this.$emit('closed', event)\n      if (stopEvent) return\n      this.params = {}\n    },\n    onClickContainer() {\n      this.$emit('click-outside', this.createModalEvent({ type: 'click-outside' }))\n      this.clickToClose && this.$emit('input', false)\n    },\n    onEsc() {\n      if (this.visible && this.escToClose) {\n        this.$emit('input', false)\n      }\n    },\n    createModalEvent(eventProps = {}) {\n      return {\n        ref: this,\n        ...eventProps\n      }\n    },\n    emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = this.createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      this.$emit(eventType, event)\n      if (stopEvent) {\n        this.stopEvent = true\n        this.$emit('input', value)\n        return true\n      }\n      return false\n    },\n    toggle(show, params) {\n      const value = typeof show === 'boolean' ? show : !this.value\n      if (value && arguments.length === 2) {\n        this.params = params\n      }\n      this.$emit('input', value)\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter,\n.vfm-leave-to {\n  opacity: 0;\n}\n</style>\n","import VueFinalModal from './VueFinalModal.vue'\nimport ModalsContainer from './ModalsContainer.vue'\n\nfunction assignOptions(component, options) {\n  const _component = { ...component }\n  Object.assign(_component.props, {\n    $_options: { type: Object, default: () => options }\n  })\n  return _component\n}\n\nfunction createVfm(Vue, options) {\n  let vfm\n\n  return function() {\n    vfm = {\n      show(modal, ...args) {\n        switch (typeof modal) {\n          case 'string':\n            this.toggle(modal, true, ...args)\n            break\n          case 'object':\n            {\n              const defaultModal = {\n                value: true,\n                id: Symbol('dynamicModal'),\n                component: options.componentName,\n                bind: {},\n                slots: {},\n                on: {},\n                params: args[0]\n              }\n              this.dynamicModals.push(Object.assign(defaultModal, modal))\n            }\n            break\n        }\n      },\n      hide(...names) {\n        this.toggle(names, false)\n      },\n      hideAll() {\n        for (let i = this.openedModals.length - 1; i >= 0; i--) {\n          this.openedModals[i].$emit('input', false)\n        }\n      },\n      toggle(name, ...args) {\n        const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\n        modals.forEach(modal => modal.toggle(...args))\n      },\n      get(...names) {\n        return this.modals.filter(modal => names.includes(modal.name))\n      },\n      dynamicModals: [],\n      openedModals: [],\n      modals: []\n    }\n    return Vue.observable(vfm)\n  }\n}\n\nexport function bindPrototype(Vue, options) {\n  const vfm = createVfm(Vue, options)()\n  Object.defineProperty(Vue.prototype, options.key, {\n    get() {\n      return vfm\n    }\n  })\n}\n\nexport function registModal(Vue, options) {\n  Vue.component(options.componentName, assignOptions(VueFinalModal, options))\n}\nexport function registContainer(Vue, options) {\n  Vue.component(options.dynamicContainerName, assignOptions(ModalsContainer, options))\n}\n","export const DUPLICATE_KEY = '[vue-final-modal] Duplicate registration API key of VueFinalModal.'\n\nexport const DUPLICATE_COMPONENT = '[vue-final-modal] Duplicate registration componentName of VueFinalModal.'\n\nexport const DUPLICATE_DYNAMIC_CONTAINER =\n  '[vue-final-modal] Duplicate registration dynamicContainerName of ModalsContainer.'\n","import { bindPrototype, registModal, registContainer } from './PluginCore'\nimport { DUPLICATE_KEY, DUPLICATE_COMPONENT, DUPLICATE_DYNAMIC_CONTAINER } from './utils/errors'\n\nconst defaultOptions = {\n  componentName: 'VueFinalModal',\n  dynamicContainerName: 'ModalsContainer',\n  key: '$vfm'\n}\n\nconst validPlugin = (duplicateKey, duplicateComponent, duplicateDynamicContainer) => {\n  if (!(duplicateKey || duplicateComponent || duplicateDynamicContainer)) return true\n\n  if (typeof window === 'undefined') return false\n\n  duplicateKey && console.error(DUPLICATE_KEY)\n  duplicateComponent && console.error(DUPLICATE_COMPONENT)\n  duplicateDynamicContainer && console.error(DUPLICATE_DYNAMIC_CONTAINER)\n\n  return false\n}\n\nconst Plugin = pluginOptions => ({\n  install(Vue, options) {\n    const _options = Object.assign({}, defaultOptions, pluginOptions, options)\n    const duplicateKey = Vue.prototype[_options.key]\n    const duplicateComponent = Vue.options.components[_options.componentName]\n    const duplicateDynamicContainer = Vue.options.components[_options.dynamicContainerName]\n\n    if (validPlugin(duplicateKey, duplicateComponent, duplicateDynamicContainer)) {\n      bindPrototype(Vue, _options)\n      registModal(Vue, _options)\n      registContainer(Vue, _options)\n    }\n  }\n})\n\nexport default Plugin\n"],"names":["isFocused","element","document","activeElement","FocusTrap","constructor","root","elements","onKeyDown","this","bind","enable","disable","firstElement","lastElement","length","event","key","keyCode","isTabPressed","shiftKey","focus","preventDefault","enabled","selector","querySelectorAll","addEventListener","removeEventListener","hasPassiveEvents","window","passiveTestOptions","isIosDevice","navigator","platform","test","maxTouchPoints","previousBodyOverflowSetting","previousBodyPaddingRight","locks","documentListenerAdded","clientY","initialClientY","hasAnyScrollableEl","el","delta","path","push","classList","contains","parentElement","composedPath","forEach","nodeType","Node","ELEMENT_NODE","style","getComputedStyle","includes","overflowY","scrollHeight","clientHeight","hasScrollbar","scrollTop","shouldScroll","allowTouchMove","some","rawEvent","e","target","touches","disableBodyScroll","targetElement","options","console","error","lock","ontouchstart","targetTouches","ontouchmove","isTargetElementTotallyScrolled","stopPropagation","handleScroll","passive","undefined","reserveScrollBarGap","scrollBarGap","innerWidth","documentElement","clientWidth","computedBodyPaddingRight","parseInt","body","getPropertyValue","paddingRight","overflow","setOverflowHidden","enableBodyScroll","filter","assignOptions","component","_component","Object","assign","props","$_options","type","default","bindPrototype","Vue","vfm","show","modal","args","toggle","defaultModal","value","id","Symbol","componentName","slots","on","params","dynamicModals","hide","names","hideAll","i","openedModals","$emit","name","Array","isArray","get","modals","observable","createVfm","defineProperty","prototype","defaultOptions","dynamicContainerName","pluginOptions","install","_options","duplicateKey","duplicateComponent","duplicateDynamicContainer","validPlugin","components","VueFinalModal","registModal","ModalsContainer","registContainer"],"mappings":"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"}