{"version":3,"file":"VueFinalModal.esm.js","sources":["../lib/utils/focusTrap.js","../lib/utils/bodyScrollLock.js","../lib/VueFinalModal.vue","../lib/VueFinalModal.vue?vue&type=template&id=2836fdb5&lang.js","../node_modules/style-inject/dist/style-inject.es.js","../lib/ModalsContainer.vue","../lib/ModalsContainer.vue?vue&type=template&id=74d49173&lang.js","../lib/PluginCore.js","../lib/utils/errors.js","../lib/Plugin.js"],"sourcesContent":["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n","// stolen from body-scroll-lock\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    }\n  }\n  window.addEventListener('testPassive', null, passiveTestOptions)\n  window.removeEventListener('testPassive', null, passiveTestOptions)\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\n\nlet locks = []\nlet documentListenerAdded = false\nlet clientY = 0\nlet initialClientY = -1\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst hasScrollbar = el => {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\n\n  const style = window.getComputedStyle(el)\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\n}\n\nconst shouldScroll = (el, delta) => {\n  if (el.scrollTop === 0 && delta < 0) return false\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\n  return true\n}\n\nconst composedPath = el => {\n  const path = []\n  while (el) {\n    path.push(el)\n    if (el.classList.contains('vfm')) return path\n    el = el.parentElement\n  }\n  return path\n}\n\nconst hasAnyScrollableEl = (el, delta) => {\n  let hasAnyScrollableEl = false\n  const path = composedPath(el)\n  path.forEach(el => {\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\n      hasAnyScrollableEl = true\n    }\n  })\n  return hasAnyScrollableEl\n}\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\n\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = targetElement =>\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\n\nconst handleScroll = (event, targetElement) => {\n  clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {}\n  }\n\n  locks = [...locks, lock]\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = true\n    }\n  } else {\n    setOverflowHidden(options)\n  }\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = false\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @click.self=\"onClickContainer\"\n      >\n        <div class=\"vfm__content\" :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\" :style=\"contentStyle\">\n          <slot :params=\"params\" />\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch, inject } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [String, Object, Array], default: '' },\n    overlayStyle: { type: [String, Object, Array], default: '' },\n    contentStyle: { type: [String, Object, Array], default: '' },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const $vfm = inject(props.options.key)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n\n    $vfm.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = $vfm.modals.findIndex(vm => vm.uid === uid)\n      $vfm.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          props.attach !== false && target.appendChild(root.value)\n\n          let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            $vfm.openedModals.splice(index, 1)\n          }\n          $vfm.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = $vfm.openedModals.length - 1\n\n          handleLockScroll()\n\n          $vfm.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                vm.visibility.overlay = false\n              }\n            })\n\n          visible.value = true\n          nextTick(() => {\n            startTransitionEnter()\n          })\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        $vfm.openedModals.splice(index, 1)\n      }\n      if ($vfm.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = $vfm.openedModals[$vfm.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      if (props.focusTrap) {\n        $focusTrap.enable(vfmContainer.value)\n      }\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onClickContainer() {\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onClickContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n</style>\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @click.self=\"onClickContainer\"\n      >\n        <div class=\"vfm__content\" :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\" :style=\"contentStyle\">\n          <slot :params=\"params\" />\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch, inject } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [String, Object, Array], default: '' },\n    overlayStyle: { type: [String, Object, Array], default: '' },\n    contentStyle: { type: [String, Object, Array], default: '' },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false }\n  },\n  emits: ['update:modelValue', 'click-outside', 'before-open', 'opened', 'before-close', 'closed'],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const $vfm = inject(props.options.key)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n\n    $vfm.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = $vfm.modals.findIndex(vm => vm.uid === uid)\n      $vfm.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        if (emitEvent('before-open', false)) {\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          props.attach !== false && target.appendChild(root.value)\n\n          let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            $vfm.openedModals.splice(index, 1)\n          }\n          $vfm.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = $vfm.openedModals.length - 1\n\n          handleLockScroll()\n\n          $vfm.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                vm.visibility.overlay = false\n              }\n            })\n\n          visible.value = true\n          nextTick(() => {\n            startTransitionEnter()\n          })\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        $vfm.openedModals.splice(index, 1)\n      }\n      if ($vfm.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = $vfm.openedModals[$vfm.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      if (props.focusTrap) {\n        $focusTrap.enable(vfmContainer.value)\n      }\n      emit('opened', createModalEvent({ type: 'opened' }))\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('closed', event)\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onClickContainer() {\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function toggle(show, _params) {\n      const value = typeof show === 'boolean' ? show : !props.modelValue\n      if (value && arguments.length === 2) {\n        params.value = _params\n      }\n      emit('update:modelValue', value)\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onClickContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n</style>\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  computed: {\n    api() {\n      return this[this.options.key]\n    }\n  },\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  computed: {\n    api() {\n      return this[this.options.key]\n    }\n  },\n  methods: {\n    slice(index) {\n      console.log('slice')\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      console.log('beforeOpen')\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n","import VueFinalModal from './VueFinalModal.vue'\nimport ModalsContainer from './ModalsContainer.vue'\nimport { shallowReactive } from 'vue'\n\nfunction assignOptions(component, options) {\n  const _component = { ...component }\n  Object.assign(_component.props, {\n    options: { type: Object, default: () => options }\n  })\n  return _component\n}\n\nfunction createVfm(options) {\n  let vfm\n\n  return function() {\n    vfm = {\n      show(modal, ...args) {\n        switch (typeof modal) {\n          case 'string':\n            return this.toggle(modal, true, ...args)\n          case 'object': {\n            return Promise.allSettled([\n              new Promise((resolve, reject) => {\n                const defaultModal = {\n                  value: true,\n                  id: Symbol('dynamicModal'),\n                  component: options.componentName,\n                  bind: {},\n                  slots: {},\n                  on: {},\n                  params: args[0],\n                  reject,\n                  opened() {\n                    resolve('show')\n                  }\n                }\n                this.dynamicModals.push(shallowReactive(Object.assign(defaultModal, modal)))\n              })\n            ])\n          }\n        }\n      },\n      hide(...names) {\n        return this.toggle(names, false)\n      },\n      hideAll() {\n        return this.hide(...this.openedModals.map(modal => modal.props.name))\n      },\n      toggle(name, ...args) {\n        const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\n        return Promise.allSettled(modals.map(modal => modal.toggle(...args)))\n      },\n      get(...names) {\n        return this.modals.filter(modal => names.includes(modal.props.name))\n      },\n      dynamicModals: shallowReactive([]),\n      openedModals: [],\n      modals: []\n    }\n    return vfm\n  }\n}\n\nexport function bindPrototype(app, options) {\n  const vfm = createVfm(options)()\n  Object.defineProperty(app.config.globalProperties, options.key, {\n    get() {\n      return vfm\n    }\n  })\n  app.provide(options.key, vfm)\n}\n\nexport function registModal(app, options) {\n  app.component(options.componentName, assignOptions(VueFinalModal, options))\n}\nexport function registContainer(app, options) {\n  app.component(options.dynamicContainerName, assignOptions(ModalsContainer, options))\n}\n","export const DUPLICATE_KEY = '[vue-final-modal] Duplicate registration API key of VueFinalModal.'\n\nexport const DUPLICATE_COMPONENT = '[vue-final-modal] Duplicate registration componentName of VueFinalModal.'\n\nexport const DUPLICATE_DYNAMIC_CONTAINER =\n  '[vue-final-modal] Duplicate registration dynamicContainerName of ModalsContainer.'\n","import { bindPrototype, registModal, registContainer } from './PluginCore'\nimport { DUPLICATE_KEY, DUPLICATE_COMPONENT, DUPLICATE_DYNAMIC_CONTAINER } from './utils/errors'\n\nconst defaultOptions = {\n  componentName: 'VueFinalModal',\n  dynamicContainerName: 'ModalsContainer',\n  key: '$vfm'\n}\n\nconst validPlugin = (duplicateKey, duplicateComponent, duplicateDynamicContainer) => {\n  if (!(duplicateKey || duplicateComponent || duplicateDynamicContainer)) return true\n\n  if (typeof window === 'undefined') return false\n\n  duplicateKey && console.error(DUPLICATE_KEY)\n  duplicateComponent && console.error(DUPLICATE_COMPONENT)\n  duplicateDynamicContainer && console.error(DUPLICATE_DYNAMIC_CONTAINER)\n\n  return false\n}\n\nconst Plugin = pluginOptions => ({\n  install(app, options) {\n    const _options = Object.assign({}, defaultOptions, pluginOptions, options)\n    const duplicateKey = app.config.globalProperties[_options.key]\n    const duplicateComponent = app._context.components[_options.componentName]\n    const duplicateDynamicContainer = app._context.components[_options.dynamicContainerName]\n\n    if (validPlugin(duplicateKey, duplicateComponent, duplicateDynamicContainer)) {\n      bindPrototype(app, _options)\n      registModal(app, _options)\n      registContainer(app, _options)\n    }\n  }\n})\n\nexport default Plugin\n"],"names":["queryFocusableElements","element","selector","querySelectorAll","isFocused","document","activeElement","FocusTrap","root","elements","onKeyDown","this","bind","enable","disable","firstElement","lastElement","length","event","key","keyCode","isTabPressed","shiftKey","focus","preventDefault","addEventListener","removeEventListener","hasPassiveEvents","window","passiveTestOptions","previousBodyOverflowSetting","previousBodyPaddingRight","isIosDevice","navigator","platform","test","maxTouchPoints","locks","documentListenerAdded","clientY","initialClientY","hasAnyScrollableEl","el","delta","path","push","classList","contains","parentElement","composedPath","forEach","nodeType","Node","ELEMENT_NODE","style","getComputedStyle","includes","overflowY","scrollHeight","clientHeight","hasScrollbar","scrollTop","shouldScroll","allowTouchMove","some","rawEvent","e","target","touches","disableBodyScroll","targetElement","options","lock","ontouchstart","targetTouches","ontouchmove","isTargetElementTotallyScrolled","stopPropagation","handleScroll","passive","undefined","reserveScrollBarGap","scrollBarGap","innerWidth","documentElement","clientWidth","computedBodyPaddingRight","parseInt","body","getPropertyValue","paddingRight","overflow","setOverflowHidden","console","error","enableBodyScroll","filter","noop","TransitionState","props","name","type","String","modelValue","Boolean","ssr","classes","Object","Array","overlayClass","contentClass","styles","overlayStyle","contentStyle","lockScroll","hideOverlay","clickToClose","escToClose","preventClick","attach","validator","val","transition","overlayTransition","zIndexAuto","zIndexBase","Number","zIndex","focusRetain","focusTrap","emits","setup","emit","uid","Symbol","ref","vfmContainer","vfmOverlayTransition","vfmTransition","$vfm","inject","modalStackIndex","$focusTrap","visible","visibility","reactive","modal","overlay","overlayTransitionState","modalTransitionState","_stopEvent","params","resolveToggle","rejectToggle","computedOverlayTransition","computed","computedTransition","isComponentReadyToBeDestroyed","value","calculateZIndex","bindStyle","getModalInfo","getAttachElement","handleLockScroll","toggle","mounted","createModalEvent","emitEvent","appendChild","index","openedModals","findIndex","vm","splice","nextTick","warn","concat","close","$_vm","querySelector","eventProps","eventType","stopEvent","stop","show","_params","Promise","resolve","reject","res","err","arguments","watch","display","flush","modals","onMounted","onBeforeUnmount","remove","beforeOverlayEnter","afterOverlayEnter","beforeOverlayLeave","afterOverlayLeave","beforeModalEnter","afterModalEnter","beforeModalLeave","enabled","afterModalLeave","onClickContainer","onEsc","$props","$setup","_createBlock","onKeydown","_createVNode","_mergeProps","onBeforeEnter","onAfterEnter","onBeforeLeave","onAfterLeave","toString","role","tabindex","onClick","_renderSlot","css","insertAt","head","getElementsByTagName","createElement","firstChild","insertBefore","styleSheet","cssText","createTextNode","api","methods","slice","dynamicModals","beforeOpen","_this","$nextTick","isString","assignOptions","component","_component","assign","bindPrototype","app","vfm","args","allSettled","defaultModal","id","componentName","slots","on","opened","shallowReactive","hide","names","hideAll","map","isArray","get","createVfm","defineProperty","config","globalProperties","provide","_hoisted_1","$options","_toHandlers","on_closed","on_beforeOpen","on_opened","slot","_createCommentVNode","innerHTML","defaultOptions","dynamicContainerName","pluginOptions","install","_options","duplicateKey","duplicateComponent","duplicateDynamicContainer","validPlugin","_context","components","VueFinalModal","registModal","ModalsContainer","registContainer"],"mappings":"42EAEA,IAsBMA,EAAyB,SAAAC,UAJN,SAACA,EAASC,YACrBD,EAAQE,iBAAiBD,IAAa,IAI3CC,CAAiBF,EAtBxB,qWAyBIG,EAAY,SAAAH,UACTA,GAAWI,SAASC,eAOvBC,qIAEGC,KAAO,UACPC,SAAW,QAEXC,UAAYC,KAAKD,UAAUE,KAAKD,WAChCE,OAASF,KAAKE,OAAOD,KAAKD,WAC1BG,QAAUH,KAAKG,QAAQF,KAAKD,WAC5BI,aAAeJ,KAAKI,aAAaH,KAAKD,WACtCK,YAAcL,KAAKK,YAAYJ,KAAKD,wDAG3C,kBACSA,KAAKF,SAASE,KAAKF,SAASQ,OAAS,IAAM,iCAGpD,kBACSN,KAAKF,SAAS,IAAM,8BAG7B,SAAUS,MAxCS,SAAAA,SACE,QAAdA,EAAMC,KAAmC,IAAlBD,EAAME,QAwC7BC,CAAaH,QAKdA,EAAMI,gBA7BJjB,SAASC,eAsCWF,EAAUO,KAAKK,qBAClCD,eAAeQ,aACpBL,EAAMM,yBAVFpB,EAAUO,KAAKI,uBACZC,cAAcO,QACnBL,EAAMM,0CAaZ,mBACWb,KAAKH,2BAGhB,SAAOA,GACAA,SAIAA,KAAOA,OACPC,SAAWT,EAAuBW,KAAKH,WAEvCA,KAAKiB,iBAAiB,UAAWd,KAAKD,mCAG7C,gBACOF,KAAKkB,oBAAoB,UAAWf,KAAKD,gBACzCF,KAAO,0CC5FZmB,GAAmB,EACvB,GAAsB,oBAAXC,OAAwB,KAC3BC,EAAqB,eAEvBF,GAAmB,IAIvBC,OAAOH,iBAAiB,cAAe,KAAMI,GAC7CD,OAAOF,oBAAoB,cAAe,KAAMG,GAGlD,IAWIC,EACAC,EAZEC,EACc,oBAAXJ,QACPA,OAAOK,WACPL,OAAOK,UAAUC,WAChB,iBAAiBC,KAAKP,OAAOK,UAAUC,WACP,aAA9BN,OAAOK,UAAUC,UAA2BN,OAAOK,UAAUG,eAAiB,GAE/EC,EAAQ,GACRC,GAAwB,EACxBC,EAAU,EACVC,GAAkB,EA2BhBC,EAAqB,SAACC,EAAIC,OAC1BF,GAAqB,SAXN,SAAAC,WACbE,EAAO,GACNF,GAAI,IACTE,EAAKC,KAAKH,GACNA,EAAGI,UAAUC,SAAS,OAAQ,OAAOH,EACzCF,EAAKA,EAAGM,qBAEHJ,EAKMK,CAAaP,GACrBQ,SAAQ,SAAAR,IA1BM,SAAAA,OACdA,GAAMA,EAAGS,WAAaC,KAAKC,aAAc,OAAO,MAE/CC,EAAQ1B,OAAO2B,iBAAiBb,SAC/B,CAAC,OAAQ,UAAUc,SAASF,EAAMG,YAAcf,EAAGgB,aAAehB,EAAGiB,cAuBtEC,CAAalB,IApBA,SAACA,EAAIC,WACH,IAAjBD,EAAGmB,WAAmBlB,EAAQ,GAC9BD,EAAGmB,UAAYnB,EAAGiB,aAAehB,GAASD,EAAGgB,cAAgBf,EAAQ,GAkB/CmB,CAAapB,EAAIC,KACvCF,GAAqB,MAGlBA,GAIHsB,EAAiB,SAAArB,UAAML,EAAM2B,MAAK,kBAAMvB,EAAmBC,GAAKH,OAEhEf,EAAiB,SAAAyC,OACfC,EAAID,GAAYrC,OAAOV,cAMzB6C,EAAeG,EAAEC,UAIjBD,EAAEE,QAAQnD,OAAS,IAEnBiD,EAAE1C,gBAAgB0C,EAAE1C,kBAEjB,KAgEI6C,EAAoB,SAACC,EAAeC,MAE1CD,OASDjC,EAAM2B,MAAK,SAAAQ,UAAQA,EAAKF,gBAAkBA,UAIxCE,EAAO,CACXF,cAAAA,EACAC,QAASA,GAAW,IAGtBlC,cAAYA,IAAOmC,IAEfxC,GACFsC,EAAcG,aAAe,SAAAvD,GACQ,IAA/BA,EAAMwD,cAAczD,SAEtBuB,EAAiBtB,EAAMwD,cAAc,GAAGnC,UAG5C+B,EAAcK,YAAc,SAAAzD,GACS,IAA/BA,EAAMwD,cAAczD,QAnDT,SAACC,EAAOoD,GAC3B/B,EAAUrB,EAAMwD,cAAc,GAAGnC,QAAUC,GAEvCuB,EAAe7C,EAAMiD,UAIrBG,GAA6C,IAA5BA,EAAcT,WAAmBtB,EAAU,GAV3B,SAAA+B,WACrCA,GAAgBA,EAAcZ,aAAeY,EAAcT,WAAaS,EAAcX,aAclFiB,CAA+BN,IAAkB/B,EAAU,EAHtDf,EAAeN,GAQxBA,EAAM2D,mBAoCAC,CAAa5D,EAAOoD,IAInBhC,IACHjC,SAASoB,iBAAiB,YAAaD,EAAgBG,EAAmB,CAAEoD,SAAS,QAAUC,GAC/F1C,GAAwB,IAnGJ,SAAAiC,WAESS,IAA7BjD,EAAwC,KACpCkD,IAAwBV,IAA2C,IAAhCA,EAAQU,oBAC3CC,EAAetD,OAAOuD,WAAa9E,SAAS+E,gBAAgBC,eAE9DJ,GAAuBC,EAAe,EAAG,KACrCI,EAA2BC,SAAShC,iBAAiBlD,SAASmF,MAAMC,iBAAiB,iBAAkB,IAC7G1D,EAA2B1B,SAASmF,KAAKlC,MAAMoC,aAC/CrF,SAASmF,KAAKlC,MAAMoC,uBAAkBJ,EAA2BJ,cAIjCF,IAAhClD,IACFA,EAA8BzB,SAASmF,KAAKlC,MAAMqC,SAClDtF,SAASmF,KAAKlC,MAAMqC,SAAW,UAuF/BC,CAAkBrB,SArClBsB,QAAQC,MACN,mHAwCOC,EAAmB,SAAAzB,GACzBA,GAQLjC,EAAQA,EAAM2D,QAAO,SAAAxB,UAAQA,EAAKF,gBAAkBA,KAEhDtC,GACFsC,EAAcG,aAAe,KAC7BH,EAAcK,YAAc,KAExBrC,GAA0C,IAAjBD,EAAMpB,SACjCZ,SAASqB,oBAAoB,YAAaF,EAAgBG,EAAmB,CAAEoD,SAAS,QAAUC,GAClG1C,GAAwB,IAEhBD,EAAMpB,cAzGe+D,IAA7BjD,IACF1B,SAASmF,KAAKlC,MAAMoC,aAAe3D,EAInCA,OAA2BiD,QAGOA,IAAhClD,IACFzB,SAASmF,KAAKlC,MAAMqC,SAAW7D,EAI/BA,OAA8BkD,KA4E9Ba,QAAQC,MACN,iHC1IAG,EAAO,aAEPC,EACG,QADHA,GAEM,WAFNA,GAGG,QAHHA,GAIK,YAGI,CACbC,MAAO,CACLC,KAAM,CAAEC,KAAMC,eAAiB,MAC/BC,WAAY,CAAEF,KAAMG,iBAAkB,GACtCC,IAAK,CAAEJ,KAAMG,iBAAkB,GAC/BE,QAAS,CAAEL,KAAM,CAACC,OAAQK,OAAQC,eAAiB,IACnDC,aAAc,CAAER,KAAM,CAACC,OAAQK,OAAQC,eAAiB,IACxDE,aAAc,CAAET,KAAM,CAACC,OAAQK,OAAQC,eAAiB,IACxDG,OAAQ,CAAEV,KAAM,CAACC,OAAQK,OAAQC,eAAiB,IAClDI,aAAc,CAAEX,KAAM,CAACC,OAAQK,OAAQC,eAAiB,IACxDK,aAAc,CAAEZ,KAAM,CAACC,OAAQK,OAAQC,eAAiB,IACxDM,WAAY,CAAEb,KAAMG,iBAAkB,GACtCW,YAAa,CAAEd,KAAMG,iBAAkB,GACvCY,aAAc,CAAEf,KAAMG,iBAAkB,GACxCa,WAAY,CAAEhB,KAAMG,iBAAkB,GACtCc,aAAc,CAAEjB,KAAMG,iBAAkB,GACxCe,OAAQ,CACNlB,KAAM,cACG,EACTmB,mBAAUC,OACFpB,IAAcoB,SAEP,YAATpB,GAA+B,WAATA,GAEnBoB,EAAItE,WAAaC,KAAKC,eAGjCqE,WAAY,CAAErB,KAAM,CAACC,OAAQK,gBAAkB,OAC/CgB,kBAAmB,CAAEtB,KAAM,CAACC,OAAQK,gBAAkB,OACtDiB,WAAY,CAAEvB,KAAMG,iBAAkB,GACtCqB,WAAY,CAAExB,KAAM,CAACC,OAAQwB,gBAAkB,KAC/CC,OAAQ,CAAE1B,KAAM,CAACG,QAASF,OAAQwB,iBAAkB,GACpDE,YAAa,CAAE3B,KAAMG,iBAAkB,GACvCyB,UAAW,CAAE5B,KAAMG,iBAAkB,IAEvC0B,MAAO,CACL,oBACA,gBACA,cACA,SACA,eACA,SACA,eACA,UACA,WAEFC,eAAMhC,SAASiC,IAAAA,KACPC,EAAMC,OAAO,OACb9H,EAAO+H,EAAI,MACXC,EAAeD,EAAI,MACnBE,EAAuBF,EAAI,MAC3BG,EAAgBH,EAAI,MAEpBI,EAAOC,EAAOzC,EAAM5B,QAAQpD,KAE5B0H,EAAkBN,EAAI,MACtBO,EAAa,IAAIvI,EAEjBwI,EAAUR,GAAI,GACdS,EAAaC,EAAS,CAC1BC,OAAO,EACPC,SAAS,IAELC,EAAyBb,EAAI,MAC7Bc,EAAuBd,EAAI,MAC3Be,EAAaf,GAAI,GACjBgB,EAAShB,EAAI,IACfiB,EAAgBvD,EAChBwD,EAAexD,EAEbyD,EAA4BC,GAAS,iBACF,iBAA5BxD,EAAMwB,kBAAuC,CAAEvB,KAAMD,EAAMwB,wBAC1DxB,EAAMwB,sBAGdiC,EAAqBD,GAAS,iBACF,iBAArBxD,EAAMuB,WAAgC,CAAEtB,KAAMD,EAAMuB,iBACnDvB,EAAMuB,eAGdmC,EAAgCF,GAAS,kBAE1CxD,EAAMgB,aAAeiC,EAAuBU,QAAU5D,KACvDmD,EAAqBS,QAAU5D,MAI7B6D,EAAkBJ,GAAS,kBACV,IAAjBxD,EAAM4B,SACJ5B,EAAMyB,aACAzB,EAAM0B,WAAa,GAAKgB,EAAgBiB,OAAS,GAKpD3D,EAAM4B,UAIXiC,EAAYL,GAAS,wBAEO,IAA1BI,EAAgBD,OAAmB,CACrC/B,OAAQgC,EAAgBD,oBA0DrBG,UACA,CACL5B,IAAAA,EACAlC,MAAAA,EACAiC,KAAAA,EACAI,aAAAA,EACAC,qBAAAA,EACAC,cAAAA,EACAwB,iBAAAA,EACArB,gBAAAA,EACAG,WAAAA,EACAmB,iBAAAA,EACArB,WAAAA,EACAsB,OAAAA,EACAb,OAAAA,YAGKc,OACHlE,EAAMI,WAAY,IACpB6B,EAAK,eAAgBkC,EAAiB,CAAEjE,KAAM,kBAC1CkE,EAAU,eAAe,eAC3Bd,EAAa,YAIXtF,EAAS+F,OACT/F,IAA2B,IAAjBgC,EAAMoB,OAAkB,EACnB,IAAjBpB,EAAMoB,QAAoBpD,EAAOqG,YAAYhK,EAAKsJ,WAE9CW,EAAQ9B,EAAK+B,aAAaC,WAAU,SAAAC,UAAMA,EAAGvC,MAAQA,MAE1C,IAAXoC,GAEF9B,EAAK+B,aAAaG,OAAOJ,EAAO,GAElC9B,EAAK+B,aAAa7H,KAAKoH,KAEvBpB,EAAgBiB,MAAQnB,EAAK+B,aAAazJ,OAAS,EAEnDkJ,IAEAxB,EAAK+B,aACF1E,QAAO,SAAA4E,UAAMA,EAAGvC,MAAQA,KACxBnF,SAAQ,SAAC0H,EAAIH,GACRG,EAAGV,qBAAuB/F,IAE5ByG,EAAG/B,gBAAgBiB,MAAQW,EAC3BG,EAAG5B,WAAWG,SAAU,MAI9BJ,EAAQe,OAAQ,EAChBgB,GAAS,WAwDb9B,EAAWG,SAAU,EACrBH,EAAWE,OAAQ,UAtDK,IAAX/E,GACT0B,QAAQkF,KAAK,2BAA2BC,OAAO7E,EAAMoB,mBAIlD0D,QACHR,EAAQ9B,EAAK+B,aAAaC,WAAU,SAAAC,UAAMA,EAAGvC,MAAQA,SAC1C,IAAXoC,GAEF9B,EAAK+B,aAAaG,OAAOJ,EAAO,GAE9B9B,EAAK+B,aAAazJ,OAAS,EAAG,KAE1BiK,EAAOvC,EAAK+B,aAAa/B,EAAK+B,aAAazJ,OAAS,GAC1DiK,EAAK/E,MAAM8B,WAAaiD,EAAKpC,WAAW/H,eAAeQ,SACnD2J,EAAK/E,MAAM6B,aAAekD,EAAK/E,MAAM8B,YACvCiD,EAAK1C,aAAasB,MAAMvI,SAEzB2J,EAAK/E,MAAMgB,cAAgB+D,EAAKlC,WAAWG,SAAU,GAuCxDH,EAAWG,SAAU,EACrBH,EAAWE,OAAQ,WApCZiB,IACHhE,EAAMI,YACRuE,GAAS,WACH3E,EAAMe,WACR7C,EAAkBmE,EAAasB,MAAO,CACpC7E,qBAAqB,IAGvBc,EAAiByC,EAAasB,mBAK7BI,WAEc,IAAjB/D,EAAMoB,SAEyB,iBAAjBpB,EAAMoB,SAElB3F,QACOA,OAAOvB,SAAS8K,cAAchF,EAAMoB,QAMtCpB,EAAMoB,iBA0EV+C,QAAiBc,yDAAa,aAEnC7C,IAAK0B,KACFmB,YAGEb,EAAUc,EAAWvB,OACxBwB,GAAY,EACVpK,EAAQoJ,EAAiB,CAC7BjE,KAAMgF,EACNE,gBACED,GAAY,YAGhBlD,EAAKiD,EAAWnK,KACZoK,IACFhC,EAAWQ,OAAQ,EACnBgB,GAAS,WACP1C,EAAK,oBAAqB0B,OAErB,YAIFM,EAAOoB,EAAMC,0BACb,IAAIC,SAAQ,SAACC,EAASC,GAC3BpC,EAAgB,SAAAqC,GACdF,EAAQE,GACRrC,EAAgBvD,GAElBwD,EAAe,SAAAqC,GACbF,EAAOE,GACPrC,EAAexD,OAEX6D,EAAwB,kBAAT0B,EAAqBA,GAAQrF,EAAMI,WACpDuD,GAA8B,IAArBiC,EAAU9K,SACrBsI,EAAOO,MAAQ2B,GAEjBrD,EAAK,oBAAqB0B,aA5Q9BkC,GACE,kBAAM7F,EAAMI,cACZ,SAAAuD,MACMR,EAAWQ,MACbR,EAAWQ,OAAQ,UAGrBO,KACKP,EAAO,IACNS,EAAU,gBAAgB,eAC5Bd,EAAa,QAGfwB,QAINe,GAAM,kBAAM7F,EAAMe,aAAYiD,GAC9B6B,GACE,kBAAM7F,EAAMgB,eACZ,SAAA2C,GACM3D,EAAMI,aAAeuD,IACvBd,EAAWG,SAAU,MAI3B6C,GAAM,kBAAM7F,EAAMoB,SAAQ8C,GAC1B2B,EACEnC,GACA,SAAApC,GACMA,IACFsB,EAAQe,OAAQ,EAChBtB,EAAasB,MAAMxG,MAAM2I,QAAU,UAGvC,CACEC,MAAO,SAIXvD,EAAKwD,OAAOtJ,KAAKoH,KAEjBmC,GAAU,WACR/B,OAEFgC,GAAgB,iBACdpB,IACA9E,EAAMe,YAAcsB,EAAasB,OAAS/D,EAAiByC,EAAasB,OACxEtJ,MAAAA,aAAAA,EAAMsJ,sBAAOwC,aAET7B,EAAQ9B,EAAKwD,OAAOxB,WAAU,SAAAC,UAAMA,EAAGvC,MAAQA,KACnDM,EAAKwD,OAAOtB,OAAOJ,EAAO,MA4NrB,CACLjK,KAAAA,EACAgI,aAAAA,EACAC,qBAAAA,EACAC,cAAAA,EACAgB,0BAAAA,EACAE,mBAAAA,EACAb,QAAAA,EACAC,WAAAA,EACAO,OAAAA,EACAQ,gBAAAA,EACAC,UAAAA,EACAuC,8BAjHAnD,EAAuBU,MAAQ5D,IAkH/BsG,6BA/GApD,EAAuBU,MAAQ5D,GAgH/BuG,8BA7GArD,EAAuBU,MAAQ5D,IA8G/BwG,6BA3GAtD,EAAuBU,MAAQ5D,IA4G/ByG,4BAzGAtD,EAAqBS,MAAQ5D,IA0G7B0G,2BAvGAvD,EAAqBS,MAAQ5D,GACzBC,EAAM6B,aAAe7B,EAAM8B,YAC7BO,EAAasB,MAAMvI,QAEjB4E,EAAM8B,WACRa,EAAWjI,OAAO2H,EAAasB,OAEjC1B,EAAK,WACLA,EAAK,SAAUkC,EAAiB,CAAEjE,KAAM,YACxCmD,EAAc,SA+FdqD,4BA5FAxD,EAAqBS,MAAQ5D,GAEzB4C,EAAWgE,WACbhE,EAAWhI,WA0FbiM,2BAtFA1D,EAAqBS,MAAQ5D,GAC7B2C,EAAgBiB,MAAQ,KACxB3D,EAAMe,YAAcnB,EAAiByC,EAAasB,WAE9CwB,GAAY,EACVpK,EAAQoJ,EAAiB,CAC7BjE,KAAM,SACNkF,gBACED,GAAY,KAGhBlD,EAAK,WACLA,EAAK,SAAUlH,GACfsI,EAAc,QACV8B,IACJ/B,EAAOO,MAAQ,KAwEfkD,4BArEA5E,EAAK,gBAAiBkC,EAAiB,CAAEjE,KAAM,mBAC/CF,EAAMiB,cAAgBgB,EAAK,qBAAqB,IAqEhD6E,iBAlEIlE,EAAQe,OAAS3D,EAAMkB,YACzBe,EAAK,qBAAqB,mEC7YxB8E,OAAOC,iBADfC,eAGE7E,IAAI,OACHjF,MAAO6J,mBACF,uBACGD,2DAA0EA,kBAClFG,2CAAaF,kDAEdG,IAAAC,+BAEGC,cAAcL,qBACdM,aAAaN,oBACbO,cAAcP,qBACdQ,aAAaR,mCAEd,mBACSD,eAAeC,aAAWhE,aADnCiE,sBAEQ,qDACEF,gBACP5J,MAAO4J,mHAGZI,IAAAC,wBAEGC,cAAcL,mBACdM,aAAaN,kBACbO,cAAcP,mBACdQ,aAAaR,iCAEd,oBAAAG,SAEE/E,IAAI,sBACE,4DACE2E,WACP5J,MAAO4J,yBACQC,aAAWjE,MAAM0E,WACjCC,KAAK,sBACM,OACXC,SAAS,KACRC,yCAAYZ,yEAEbG,gBAAW,gBAAwBJ,oCAAqCA,kBAAkB5J,MAAO4J,iBAC/Fc,sBAAOzE,OAAQ4D,0CAZTA,aAAWjE,iGA7BdgE,OAAOC,8BCHpB,SAAqBc,EAAK1F,QACX,IAARA,IAAiBA,EAAM,QACxB2F,EAAW3F,EAAI2F,YAEdD,GAA2B,oBAAb5N,cAEf8N,EAAO9N,SAAS8N,MAAQ9N,SAAS+N,qBAAqB,QAAQ,GAC9D9K,EAAQjD,SAASgO,cAAc,SACnC/K,EAAM+C,KAAO,WAEI,QAAb6H,GACEC,EAAKG,WACPH,EAAKI,aAAajL,EAAO6K,EAAKG,YAKhCH,EAAK3D,YAAYlH,GAGfA,EAAMkL,WACRlL,EAAMkL,WAAWC,QAAUR,EAE3B3K,EAAMkH,YAAYnK,SAASqO,eAAeT,2vBCA9C,OAAe,CACb9H,MAAO,GACPwD,SAAU,CACRgF,sBACShO,KAAKA,KAAK4D,QAAQpD,OAG7ByN,QAAS,CACPC,eAAMpE,QACCkE,IAAIG,cAAcjE,OAAOJ,EAAO,IAEjCsE,oBAAW7K,EAAGgF,EAAOuB,qCACzBvG,EAAEqE,IAAIgB,OAAOO,MAAQZ,EAAMK,aACrByF,EAAKC,kBACLD,EAAKC,YACN/F,EAAMY,QACTkF,EAAKH,MAAMpE,GACXvB,EAAM0C,OAAO,4LAGjBsD,kBAASzH,SACe,iBAARA,eC3CP,oBCGb,SAAS0H,GAAcC,EAAW7K,OAC1B8K,OAAkBD,UACxBzI,OAAO2I,OAAOD,EAAWlJ,MAAO,CAC9B5B,QAAS,CAAE8B,KAAMM,eAAiB,kBAAMpC,MAEnC8K,EAuDF,SAASE,GAAcC,EAAKjL,OAC3BkL,EArDR,SAAmBlL,UAGV,iBACC,CACJiH,cAAKtC,qCAAUwG,mCAAAA,6BACExG,QACR,gBACIvI,KAAKyJ,mBAAOlB,GAAO,UAASwG,QAChC,gBACIhE,QAAQiE,WAAW,CACxB,IAAIjE,SAAQ,SAACC,EAASC,OACdgE,EAAe,CACnB9F,OAAO,EACP+F,GAAIvH,OAAO,gBACX8G,UAAW7K,EAAQuL,cACnBlP,KAAM,GACNmP,MAAO,GACPC,GAAI,GACJzG,OAAQmG,EAAK,GACb9D,OAAAA,EACAqE,kBACEtE,EAAQ,UAGZqD,EAAKF,cAAcjM,KAAKqN,EAAgBvJ,OAAO2I,OAAOM,EAAc1G,YAM9EiH,2CAAQC,2BAAAA,yBACCzP,KAAKyJ,OAAOgG,GAAO,IAE5BC,0BACS1P,KAAKwP,kBAAQxP,KAAK+J,aAAa4F,KAAI,SAAApH,UAASA,EAAM/C,MAAMC,WAEjEgE,gBAAOhE,8BAASsJ,mCAAAA,wBACRvD,EAASvF,MAAM2J,QAAQnK,GAAQzF,KAAK6P,iBAAOpK,IAAQzF,KAAK6P,IAAIpK,UAC3DsF,QAAQiE,WAAWxD,EAAOmE,KAAI,SAAApH,UAASA,EAAMkB,aAANlB,EAAgBwG,QAEhEc,0CAAOJ,2BAAAA,yBACEzP,KAAKwL,OAAOnG,QAAO,SAAAkD,UAASkH,EAAM5M,SAAS0F,EAAM/C,MAAMC,UAEhE0I,cAAeoB,EAAgB,IAC/BxF,aAAc,GACdyB,OAAQ,KAOAsE,CAAUlM,EAAVkM,GACZ9J,OAAO+J,eAAelB,EAAImB,OAAOC,iBAAkBrM,EAAQpD,IAAK,CAC9DqP,sBACSf,KAGXD,EAAIqB,QAAQtM,EAAQpD,IAAKsO,8CDtEzBrC,QAAA0D,WACE1D,WAE2B2D,MAAIjC,wBAArB5F,EAAOuB,cAFjB2C,IACOlE,EAAMkG,WADb7B,GAGGpM,IAAK+H,EAAM2G,IACJ3G,EAAMtI,iBACLsI,EAAMY,+CAANZ,EAAMY,UACfkH,IAAYhB,KACXiB,6BAASF,QAAMtG,IACfyG,cAAa,SAAAhN,UAAK6M,aAAW7M,EAAGgF,IAChCiI,UAASjI,EAAM+G,oBAEgB/G,EAAM6G,gBAApBqB,EAAMjQ,eAAsBA,QAC5C,kBAAAkQ,oCACWN,WAASK,QAApBhE,eAA2BkE,UAAQF,+BACnChE,IAAgBgE,EAAKhC,WAArB7B,UAA+C6D,EAAKxQ,KAAMoQ,EAAMI,EAAKpB,gKEhBtE,ICGDuB,GAAiB,CACrBzB,cAAe,gBACf0B,qBAAsB,kBACtBrQ,IAAK,uBAeQ,SAAAsQ,SAAkB,CAC/BC,iBAAQlC,EAAKjL,OACLoN,EAAWhL,OAAO2I,OAAO,GAAIiC,GAAgBE,EAAelN,IAdlD,SAACqN,EAAcC,EAAoBC,WAC/CF,GAAgBC,GAAsBC,KAEtB,oBAAXlQ,SAEXgQ,GAAgB/L,QAAQC,MDdG,sECe3B+L,GAAsBhM,QAAQC,MDbG,4ECcjCgM,GAA6BjM,QAAQC,MDXrC,uFCO0C,IAgBpCiM,CAJiBvC,EAAImB,OAAOC,iBAAiBe,EAASxQ,KAC/BqO,EAAIwC,SAASC,WAAWN,EAAS7B,eAC1BN,EAAIwC,SAASC,WAAWN,EAASH,yBAGjEjC,GAAcC,EAAKmC,GF6ClB,SAAqBnC,EAAKjL,GAC/BiL,EAAIJ,UAAU7K,EAAQuL,cAAeX,GAAc+C,GAAe3N,IE7C9D4N,CAAY3C,EAAKmC,GF+ChB,SAAyBnC,EAAKjL,GACnCiL,EAAIJ,UAAU7K,EAAQiN,qBAAsBrC,GAAciD,GAAiB7N,IE/CvE8N,CAAgB7C,EAAKmC"}